<html>
<head>
<script src="https://togetherjs.com/togetherjs-min.js"></script>
<script src="./draggable.js"></script>
<style>
#gamearea {
  background-color: darkgreen;
  width: 80%;
  height: 300px;
}
.static {
  cursor: not-allowed;
}
.draggable, .draggable-group {
  cursor: move; /* fallback if grab is unsupported */
  cursor: grab;
}
.draggable:active, .draggable-group:active {
  cursor: grabbing;
}

</style>

<script>

function getUserColor() {
  try {
    var el = document.getElementsByClassName('togetherjs-person-self')[0];
    return el.style.borderColor;
  }
  catch {
    return null;
  }
}


var myClientId = null;

function fire(payload) {
  if (!myClientId) {
    console.log('TogetherJS not ready for send')
    return
  }
  try {
    TogetherJS.send(payload);
  }
  catch (err) {
    console.log('togetherjs error', err);
    // TODO: pop up a dialog?
  }
}

TogetherJS.on('ready', () => {
  session = TogetherJS.require('session')
  myClientId = session.clientId;
});

TogetherJS.hub.on('syncState', (msg) => {
  console.log('syncing', msg)
  world = get_world();
  msg.data.map(payload => {
    world.appendChild(deserialize(payload))
  });
});

TogetherJS.hub.on("togetherjs.hello", (msg) => {
  console.log('hello msg', msg);
  worldData = svgMap(get_world(), (el) => {
    return serializeSvg(el);
  });
  if (worldData.length) {
    fire({
      type: "syncState",
      data: worldData,
    });
  }
});

TogetherJS.hub.on("change", (msg) => {
  console.log('change msg', msg);
  deserialize(msg.data);
});


function deserialize(payload) {
  var el = null;
  if (document.getElementById(payload.id)) {
    el = byId(payload.id);
    Object.keys(payload).map(key => {
      if (isNaN(parseInt(key)) && key !== 'kids') {
        s(el, key, payload[key]);
      }
    });
  } else {
    var fn = str_to_fn('make_' + payload['data-app-class'])
    if (fn) {
      console.log('calling ', 'make_'+ payload['data-app-class'])
      el = fn(payload.id, payload);
    } else {
      throw Error('what to do?')
    }
  }
  if (payload.kids) {
    payload.kids.map(inner_payload => {
      var kid = deserialize(inner_payload);
      if (kid.parentNode) {
        kid.remove()
      }
      el.appendChild(deserialize(inner_payload));
    });
  }
  return el;
}

TogetherJS.hub.on("create", (msg) => {
  console.log('create msg', msg);
  get_world().appendChild(deserialize(msg.data));
});

TogetherJS.hub.on("createSelect", (msg) => {
  console.log('msg', msg.data.select_rect);
  var {select_rect, target} = msg.data;
  // get local version
  target = byId(target.id);
  select_rect = make_select(select_rect.id, select_rect);
  _make_selection(target, select_rect);
});

TogetherJS.hub.on('dropSelect', (msg) => {
  _de_select(byId(msg.select_rect.id));
});


function g(el, label) {
  if (el.dataset === undefined) {
    return el[label];
  }
  if (Object.keys(el.dataset).indexOf(label) != -1) {
    return el.dataset[label];
  }
  if (Object.keys(el.attributes).indexOf(label) != -1) {
    return el.getAttribute(label);
  }
  var value = el.getAttribute(label);
  if (value !== null) {
    return value;
  }
  if (label === 'width' || label === 'height') {
    return el.getBBox()[label];
  }
}

function s(el, label, val) {
  if (val === undefined || val === null) {
    console.log('rem', label, val)
    return el.removeAttribute(label);
  }
  el.setAttribute(label, val);
}

function byId(id) {
  var rv = document.getElementById(id);
  if (!rv) {
    throw Error('element not found '+ id)
  }
  return rv;
}

function getTranslation(el) {
  // Make sure the first transform on the element is a translate transform
  var transforms = el.transform.baseVal;

  if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
    // Create an transform that translates by (0, 0)
    var translate = get_world().createSVGTransform();
    translate.setTranslate(0, 0);
    el.transform.baseVal.insertItemBefore(translate, 0);
  }
  return transforms.getItem(0);
}

function svgMap(parent, fn) {
  var retval = [];
  parent.childNodes.forEach((el) => {
    if (g(el, 'data-app-class')) {
      var result = fn(el);
      if (result) {
        retval.push(result);
      }
    }
  });
  return retval;
}

function serialize_group(group) {
  var retval = group.getAttributeNames()
  .reduce((acc,n) => {
    acc[n] = g(group, n);
    return acc
  }, {});
  retval.kids = [];
  svgMap(group, (el) => {
    retval.kids.push(serializeSvg(el));
  })
  return retval;
}

function str_to_fn(fname) {
  return (
    (window[fname] && typeof window[fname] === 'function')
    ?  window[fname]
    : null
  );
}

function serializeSvg(el) {
  console.log('trying to serialize', el)
  var fn = str_to_fn('serialize_' + g(el, 'data-app-class'))
  if (fn) {
    return fn(el);
  }
  return el.getAttributeNames()
  .reduce((acc,n) => {
    acc[n] = g(el, n);
    return acc
  }, {});
}


function move_to_center(el, target) {
  var el_transform = getTranslation(el);
  var target_transform = getTranslation(target)

  centerize = [
    parseInt(g(el, 'width'))/2 - parseInt(g(target, 'width')) / 2,
    parseInt(g(el, 'height'))/2 - parseInt(g(target, 'height')) / 2,
  ];

  console.log('from matrix', el_transform.matrix)
  console.log('to matrix', target_transform.matrix)
  console.log('cenete', centerize)

  el_transform.setTranslate(
    el_transform.matrix.e + target_transform.matrix.e - centerize[0],
    el_transform.matrix.f + target_transform.matrix.f - centerize[1],
  );
}

function move_to(el, target) {
  // move the element to where the target is
  var el_transform = getTranslation(el);
  var target_transform = getTranslation(target)

  el_transform.setTranslate(
    el_transform.matrix.e + target_transform.matrix.e,
    el_transform.matrix.f + target_transform.matrix.f,
  );
}

function randInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function SVGElem(etype, id, attrs) {
  var el = document.createElementNS('http://www.w3.org/2000/svg', etype);
  s(el, 'id', id)
  Object.keys(attrs).map(key => {
    s(el, key, attrs[key])
  })
  return el;
}

function Rect(id, attrs) {
  return SVGElem('rect', id, Object.assign({
    x: 0,
    y: 0,
  }, attrs));
}

function make_select(id, data) {
  var select_rect = Rect(id, Object.assign({
    'data-app-class': 'select',
    rx: 4,
    ry: 4,
    width: 4,
    height: 4,
    fill: 'cyan',
    'fill-opacity': 0.1,
    stroke: 'cyan',
    'stroke-opacity': 0.8,
    'stroke-width': 1,
  }, data));
  select_rect.addEventListener('dblclick', de_select);
  return select_rect;
}


function make_group(id, attrs) {
  var validAttrs = Object.keys(attrs).reduce((acc, key) => {
    if (isNaN(parseInt(key)) && key !== 'kids') {
      acc[key] = attrs[key];
    }
    return acc;
  }, {});
  var group = SVGElem('g', id, Object.assign({
    'class': 'draggable-group',
    'data-app-class': 'group',
  }, validAttrs));
  return group;
}

function _make_selection(target, select_rect) {
  //make the group
  var group = SVGElem('g', 'g' + select_rect.id, {
    'class': 'draggable-group',
    'data-app-class': 'group',
  });
  target.remove();
  group.appendChild(target);
  group.appendChild(select_rect);
  get_world().appendChild(group);
  return group;
}

function parse_transforms(str) {
  var result = {};
  for (var i in str = str.match(/(\w+)\(([^,)]+),?([^)]+)?\)/gi)) {
    var c = str[i].match(/[\w\.\-]+/g);
    result[c.shift()] = c.map(x => parseFloat(x));
  }
  return result;
}

function de_select(evt) {
  console.log('de select', evt.target)
  select_rect = evt.target;
  _de_select(select_rect);
  fire({type: "dropSelect", select_rect: serializeSvg(select_rect) });
}

function _de_select(select_rect) {
  svg = get_world();
  group = byId('g' + select_rect.id);

  //group.childNodes.forEach(target => {
  svgMap(group, (target) => {
    target.remove()
    move_to(target, group)
    svg.appendChild(target);
  })

  select_rect.remove()
  group.remove()
}

function die_select(evt) {
  // evt.target might be the rect or the text node
  console.log('sel parent', evt.target.parentNode)
  console.log('sel elem', evt.target)
  group_target = evt.target.parentNode;

  // make the highlight rectangle
  var color = getUserColor() || 'cyan';
  var select_rect = make_select('selection' + Date.now(), {
    width: parseInt(g(group_target, 'width')) + 4,
    height: parseInt(g(group_target, 'height')) + 4,
    fill: color,
    stroke: color,
  })
  move_to_center(select_rect, group_target);

  group = _make_selection(group_target, select_rect)

  fire({type: "createSelect", data: {
    select_rect: serializeSvg(select_rect),
    target: serializeSvg(group_target),
  }});
}

function make_die(id, attrs) {
  var die = Rect(id || 'die' + Date.now(), Object.assign({
    'data-app-class': 'die',
    rx: 20,
    ry: 20,
    width: 100,
    height: 100,
    //'class': 'draggable',
    fill: 'ivory',
    stroke: 'black',
    'fill-opacity': 1,
    'stroke-opacity': 0.8,
    'stroke-width': 5,
  }, attrs))
  die.addEventListener('dblclick', die_select);
  return die;
}

function Text(id, attrs) {
  textEl = SVGElem('text', id, Object.assign({
    'data-app-class': 'text',
    //'class': 'draggable',
    x: 0,
    y: 0,
    'fill': 'black',
    'fill-opacity': 1,
    'text-anchor': 'middle',
    'alignment-baseline': 'middle',
    'font-size': '30px',
  }, attrs));
  var tNode = document.createTextNode(attrs['data-text'] || 'foo');
  textEl.appendChild(tNode);
  return textEl;
}

function make_text(id, attrs) {
  var text = Text(id || 'text' + Date.now(), attrs);
  text.addEventListener('dblclick', die_select);
  return text
}

function get_world() {
  return document.getElementsByTagName('svg')[0];
}

function add_d6(e, target) {
  group = make_group('g' + Date.now(), {})
  get_world().appendChild(group);
  var die = make_die();
  group.appendChild(die)

  var txtEl = make_text('text' + Date.now(), {'data-text': randInt(1,6)})
  group.appendChild(txtEl);
  move_to_center(txtEl, die);

  fire({type: "create", data: serializeSvg(group)});
}

function initDraggable() {
  world = byId('svgdoc')
  makeDraggable(world, {
    endDragCb: (selectedElement) => {
      console.log('done drag', selectedElement)
      fire({type: "change", data: serializeSvg(selectedElement)});
    }
  });
}

</script>
</head>
<body>
<button onclick="TogetherJS(this); return false;">Start TogetherJS</button>
  <button onclick="add_d6(this)">
  Add d6
  </button>

  <input id="text1" type="text" />

  <div id="gamearea" contextmenu="gamemenu">
  <svg id="svgdoc" width="100%" height="300" onload="initDraggable()">
  </svg>
  <menu type="context" id="gamemenu">
    <menuitem label="A A A"></menuitem>
    <menuitem label="Number 2"></menuitem>
  </menu>
  </div>


</body>
</html>

