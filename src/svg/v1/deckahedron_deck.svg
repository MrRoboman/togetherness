<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="240"
   height="240"
   version="1.1"
   id="deckahedron_deck"
   class="deckahedron_deck droptarget"
   inkscape:version="0.92.3 (2405546, 2018-03-11)"
   sodipodi:docname="deckahedron_deck.svg">
  <defs
     id="defs2" />
  <script
     type="text/javascript"
     data-namespace="deckahedron_deck"
     id="deckahedron_deck"><![CDATA[

function pile_offset(index) {
  return {
    x: 0.2 * index,
    y: 0.66 * index,
  }
}

var deckahedron_deck = {
  pokerDeckJSON: [
    {name: 'Ace of Hearts', suit: '♥', rank: 'A'},
    {name: '2 of Hearts', suit: '♥', rank: '2'},
    {name: '3 of Hearts', suit: '♥', rank: '3'},
    {name: '4 of Hearts', suit: '♥', rank: '4'},
    {name: '5 of Hearts', suit: '♥', rank: '5'},
    {name: '6 of Hearts', suit: '♥', rank: '6'},
    {name: '7 of Hearts', suit: '♥', rank: '7'},
    {name: '8 of Hearts', suit: '♥', rank: '8'},
    {name: '9 of Hearts', suit: '♥', rank: '9'},
    {name: '10 of Hearts', suit: '♥', rank: '10'},
    {name: 'Jack of Hearts', suit: '♥', rank: 'J'},
    {name: 'Queen of Hearts', suit: '♥', rank: 'Q'},
    {name: 'King of Hearts', suit: '♥', rank: 'K'},
    {name: 'Ace of Clubs', suit: '♣', rank: 'A'},
    {name: '2 of Clubs', suit: '♣', rank: '2'},
    {name: '3 of Clubs', suit: '♣', rank: '3'},
    {name: '4 of Clubs', suit: '♣', rank: '4'},
    {name: '5 of Clubs', suit: '♣', rank: '5'},
    {name: '6 of Clubs', suit: '♣', rank: '6'},
    {name: '7 of Clubs', suit: '♣', rank: '7'},
    {name: '8 of Clubs', suit: '♣', rank: '8'},
    {name: '9 of Clubs', suit: '♣', rank: '9'},
    {name: '10 of Clubs', suit: '♣', rank: '10'},
    {name: 'Jack of Clubs', suit: '♣', rank: 'J'},
    {name: 'Queen of Clubs', suit: '♣', rank: 'Q'},
    {name: 'King of Clubs', suit: '♣', rank: 'K'},
    {name: 'Ace of Diamonds', suit: '♦', rank: 'A'},
    {name: '2 of Diamonds', suit: '♦', rank: '2'},
    {name: '3 of Diamonds', suit: '♦', rank: '3'},
    {name: '4 of Diamonds', suit: '♦', rank: '4'},
    {name: '5 of Diamonds', suit: '♦', rank: '5'},
    {name: '6 of Diamonds', suit: '♦', rank: '6'},
    {name: '7 of Diamonds', suit: '♦', rank: '7'},
    {name: '8 of Diamonds', suit: '♦', rank: '8'},
    {name: '9 of Diamonds', suit: '♦', rank: '9'},
    {name: '10 of Diamonds', suit: '♦', rank: '10'},
    {name: 'Jack of Diamonds', suit: '♦', rank: 'J'},
    {name: 'Queen of Diamonds', suit: '♦', rank: 'Q'},
    {name: 'King of Diamonds', suit: '♦', rank: 'K'},
    {name: 'Ace of Spades', suit: '♠', rank: 'A'},
    {name: '2 of Spades', suit: '♠', rank: '2'},
    {name: '3 of Spades', suit: '♠', rank: '3'},
    {name: '4 of Spades', suit: '♠', rank: '4'},
    {name: '5 of Spades', suit: '♠', rank: '5'},
    {name: '6 of Spades', suit: '♠', rank: '6'},
    {name: '7 of Spades', suit: '♠', rank: '7'},
    {name: '8 of Spades', suit: '♠', rank: '8'},
    {name: '9 of Spades', suit: '♠', rank: '9'},
    {name: '10 of Spades', suit: '♠', rank: '10'},
    {name: 'Jack of Spades', suit: '♠', rank: 'J'},
    {name: 'Queen of Spades', suit: '♠', rank: 'Q'},
    {name: 'King of Spades', suit: '♠', rank: 'K'},
  ],

  generate_card: function(template, cardJSON, deckEl) {
    let card = template.cloneNode(true)
    let human_readable = {
      '♠': 's',
      '♦': 'd',
      '♥': 'h',
      '♣': 'c',
    }

    card.dataset.name = cardJSON.name
    card.dataset.rank = cardJSON.rank
    card.dataset.deckId = deckEl.id
    card.id = (
      deckEl.id
      + '_'
      + cardJSON.rank
    )

    card.querySelector('.tspan_rank').textContent = cardJSON.rank

    card = SVG.adopt(card)
    card.removeClass('card_template')
    card.addClass('card')
    card.addClass('draggable-group')
    card.addClass('c' + cardJSON.rank)
    card.addClass('of_' + deckEl.id)
    card.node.dataset.appNamespaces = ['deckahedron_deck_card']

    card.node.addEventListener('svg_dragstart', (evt) => {
      console.log('card gets svg_dragstart', evt)
      if (evt.detail.elemId === card.node.id) {
        console.log('its me', card.node.id)
      }
    })
    return card
  },

  generate_deck: function(elem) {
    local_doc = SVG.adopt(elem)
    deck = local_doc.group()
    deck.addClass('deck')
    deck.addClass('contents_group')
    deck_id = 'deck_' + base32.short_id()
    deck.id(deck_id)
    local_doc.add(deck)

    let template = elem.querySelector('.card_template')
    shuffle(this.pokerDeckJSON).map((cardJSON) => {
      card = this.generate_card(template, cardJSON, deck.node)
      this.endeck(deck, card)
    })
    template.remove()
  },

  endeck: function(deck, card) {
    localDocEl = deck.node.closest('.deckahedron_deck')
    deck_area = localDocEl.querySelector('#g_deck_area')
    deck_area = SVG.adopt(deck_area)

    deckahedron_deck.flip_card_to_back(card.node)

    let offset = pile_offset(
      deck.node.querySelectorAll('.card').length
    )
    card.cy(deck_area.cy() + offset.y)
    card.cx(deck_area.cx() + offset.x)
    deck.add(card)
  },

  flip_card_to_front: function(cardEl) {
    back = cardEl.querySelector('.card_back')
    back.remove()
    cardEl.insertBefore(back, cardEl.firstChild)
  },

  flip_card_to_back: function(cardEl) {
    back = cardEl.querySelector('.card_back')
    back.remove()
    cardEl.appendChild(back)
  },

  flip_card: function(cardEl) {
    if (cardEl.lastElementChild.classList.contains('card_back')) {
      deckahedron_deck.flip_card_to_front(cardEl)
    } else {
      deckahedron_deck.flip_card_to_back(cardEl)
    }
  },

  initialize: function(elem) {
    this.generate_deck(elem)
    elem.addEventListener('deckahedron_deck_flip', this.flip_handler)
    elem.addEventListener('deckahedron_deck_reshuffle', this.reshuffle_handler)

    //elem.addEventListener('svg_drag', this.drag_handler)
    //elem.addEventListener('svg_drop', this.drop_handler)
    //elem.addEventListener('svg_dragover', this.dragover_handler)
    //elem.addEventListener('svg_dragenter', () => {console.log('E')})
    //elem.addEventListener('svg_dragleave', () => {console.log('L')})

    elem.addEventListener('dblclick', lock_selection)
  },

  menu: {
    'Flip': {
      eventName: 'deckahedron_deck_flip',
      applicable: (dNode) => {
        deck = dNode.querySelector('.deck')
        if (deck.childNodes.length > 0) {
          return true
        }
        return false
      },
    },
    'Reshuffle': {
      eventName: 'deckahedron_deck_reshuffle',
      applicable: (dNode) => { return true },
    },
  },

  flip_handler: function(evt) {
    let topcard = this.querySelector('.deck .card:last-child')
    deckahedron_deck.flip_card(topcard)
  },

  reshuffle_handler: function(evt) {
    var deck

    if (evt.target.classList.contains('deck')) {
      deck = evt.target
    } else {
      deck = evt.target.querySelector('.deck')
    }
    local_doc = deck.closest('.deckahedron_deck')

    cardArray = []
    sDeck = SVG.adopt(deck)
    local_doc.querySelectorAll('.of_' + deck.id).forEach((card) => {
      card.remove()
      cardArray.push(card)
    })
    shuffle(cardArray).map((card) => {
      sCard = SVG.adopt(card)
      deckahedron_deck.endeck(sDeck, sCard)
    })
  },

}


deckahedron_deck_card = {
  initialize: function(elem) {
    elem.addEventListener('deckahedron_deck_card_flip', this.flip_handler)
    elem.addEventListener('deckahedron_deck_card_return', this.return_handler)
    elem.addEventListener('dblclick', this.flip_handler)
  },

  return_handler: function(evt) {
    push_to_parent(
      byId(evt.target.id),
      byId(evt.target.dataset.deckId),
      (cardEl, deckEl) => {
        s(cardEl, 'data-app-class', null)
        cardEl.classList.add('draggable-group')
        deckahedron_deck.endeck(SVG.adopt(deckEl), SVG.adopt(cardEl))
      }
    )
  },

  flip_handler: function(evt) {
    deckahedron_deck.flip_card(this)
  },

  menu: {
    'Flip': {
      eventName: 'deckahedron_deck_card_flip',
      applicable: (dNode) => { return true },
    },
    'Return to deck': {
      eventName: 'deckahedron_deck_card_return',
      applicable: (dNode) => {
        console.log('dnode', dNode)
        if(document.querySelector('#' + dNode.dataset.deckId)) {
          return true
        } else {
          return false
        }
      },
    },
  },

}


    ]]></script>

  <svg
     id="card_template"
     class="card_template"
     x="40"
     y="60"
     width="100"
     height="150"
     >
    <g class="card_front">
    <rect
       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="card_face"
       width="100"
       height="150"
       x="0"
       y="0"
       rx="10"
       ry="10" />
    <text
       xml:space="preserve"
       style="font-style:normal;font-variant:normal;
       font-weight:bold;font-stretch:normal;
       font-size:50px;line-height:125%;
       font-family:serif;
       letter-spacing:0px;word-spacing:0px;
       fill:#F00000;fill-opacity:1;"
       x="33"
       y="100"
       id="text819"><tspan
         sodipodi:role="line"
         id="tspan_rank"
         class="tspan_rank"
         >K</tspan></text>
    </g>
    <g class="card_back">
    <rect
       style="opacity:1;
       fill:#ffffff;fill-opacity:1;
       stroke:#000000;stroke-width:0.5;
       stroke-opacity:1"
       id="card_back_outer"
       width="150"
       height="150"
       x="0"
       y="0"
       rx="10"
       ry="10" />
    <rect
       style="opacity:1;
       fill:#202020;fill-opacity:1;
       stroke:none"
       id="card_back_inner"
       width="140"
       height="140"
       x="5"
       y="5"
       rx="5"
       ry="5" />
    </g>
  </svg>
    <g id="g_deck_area" >
      <rect
         style="opacity:1;
         fill-opacity:0;
         stroke:#ffffff;
         stroke-width:0.5;
         stroke-opacity:0.5"
         id="deck_area_rect"
         width="240"
         height="240"
         x="0.0"
         y="0.0"
         rx="0"
         ry="0" />
    </g>
</svg>
